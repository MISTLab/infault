/***************************************************************************
 *   Copyright (C) 2007 by Simon Schulz   *
 *   Simon.Schulz@esa.int   *
 *                                                                         *
 ***************************************************************************
 *   NOTE: this edif "parser" can only read EDIFs generated by             *
 *         ngc2edif (Release 8.2i - ngc2edif I.31)                         *
 *                                                                         *
 *         this was only written as a proof of concept for the             *
 *         general idea behind this fault simulator!                       *
 *         it should be rewritten as a REAL parser for future use!         *
 ***************************************************************************
 *                                                                         *
 *   This program is free software; you can redistribute it and/or modify  *
 *   it under the terms of the GNU General Public License as published by  *
 *   the Free Software Foundation; either version 2 of the License, or     *
 *   (at your option) any later version.                                   *
 *                                                                         *
 *   This program is distributed in the hope that it will be useful,       *
 *   but WITHOUT ANY WARRANTY; without even the implied warranty of        *
 *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the         *
 *   GNU General Public License for more details.                          *
 *                                                                         *
 *   You should have received a copy of the GNU General Public License     *
 *   along with this program; if not, write to the                         *
 *   Free Software Foundation, Inc.,                                       *
 *   59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.             *
 ***************************************************************************/
#include "edif_parser.h"

EDIF_Parser::EDIF_Parser() : Parser() 
{
}

EDIF_Parser::EDIF_Parser(const char *_filename) : Parser(_filename)
{
    filename = _filename;
    input_stream.open(filename);
    
    if (!input_stream.good()){
        printf("ERROR: cant open '%s'. parse will fail...\n",filename);
    }
}

EDIF_Parser::~EDIF_Parser()
{
}


string EDIF_Parser::get_port_by_node_name(Graph *graph, string nodename)
{
    Node *io = graph->get_node_by_name(nodename.c_str());
    if (io != NULL){
        //debug_verbose_printf("%s for node %s which is a %s\n",__PRETTY_FUNCTION__,io->get_name(),typeid(*io).name());
        if (io->get_is_input()){
            return "Q";
        }else{
            return "D";
        }
    }else{
        printf("WARNING: unable to find node %s to determine if in or out\n",nodename.c_str());
        exit(-1);
    }
    //default
    return "D";
}

Graph *EDIF_Parser::get_graph()
{
    cmatch re_result;
    int parser_state = 0;
    int ff_initvalue = 0;
    char line[2048];
    
    //vector <Node*> node_vector;
    //vector <string> wire_vector;
    
    string instance = "";
    string library  = "";
    string celltype = "";
    string net = "";
    
    regex re_main     = regex("\\s*\\(\\s*library (.*)_lib(.*)", regex_constants::perl);
    regex re_port     = regex("\\s*\\(\\s*port\\s+(.*)", regex_constants::perl);
    regex re_is_input = regex("\\s*\\(\\s*direction\\s+INPUT\\s*\\).*", regex_constants::perl);
    regex re_array    = regex("\\s*\\(\\s*array\\s*\\(\\s*rename\\s+(.+)\\s+([^\\)]+)\\)\\s*(\\d+)\\s*\\).*", regex_constants::perl);
    //(array (rename memco_ramsn "memco_ramsn<4:0>") 5)'
    
    regex re_instance = regex("\\s*\\(\\s*instance\\s+(.*)", regex_constants::perl);
    regex re_net      = regex("\\s*\\(\\s*net\\s+(.*)", regex_constants::perl);
    regex re_rename   = regex("\\(\\s*rename\\s+([^\\s]+)\\s+.*\\)", regex_constants::perl);
    //
    regex re_viewref  = regex("\\s*\\(\\s*viewRef\\s+[^\\s]+\\s+\\(\\s*cellRef\\s+([^\\s]+)\\s+\\(\\s*libraryRef\\s+([^\\s\\)]+)\\s*\\).*", regex_constants::perl);
    regex re_property  = regex("\\s*\\(\\s*property\\s+([^\\s]+)\\s+\\(\\s*([^\\s]+)\\s+\"?([^\"\\s]+)\"?\\s*\\).*", regex_constants::perl);
    regex re_joined   = regex("\\s*\\(\\s*joined.*",regex_constants::perl);
    
    //regex re_portref  = regex("\\s*\\(\\s*portRef\\s+([^\\)]+)\\s*\\).*", regex_constants::perl);
    //regex re_portref_member  = regex("\\s*\\(\\s*portRef\\s+\\(\\s*member\\s+(.+)\\s+(.+)\\s*\\)\\s+([^\\)]+)\\s*\\).*", regex_constants::perl);
    //regex re_portref  = regex("\\s*\\(\\s*portRef\\s+(.+)\\s+\\(([^\\)]+)\\s*\\).*", regex_constants::perl);
    regex re_portref  = regex("\\s*\\(\\s*portRef\\s+(.+)\\s*\\).*", regex_constants::perl);
    regex re_instanceref  = regex("\\s*([^\\(]+)\\s+\\(\\s*instanceRef\\s+([^\\s\\)]+)\\s*.*", regex_constants::perl);
    
    regex re_member_instanceref  = regex("\\s*\\(member\\s+(.+)\\s+(.+)\\s*\\)\\s+\\(\\s*instanceRef\\s+([^\\s\\)]+)\\s*.*", regex_constants::perl);
    regex re_member_io  = regex("\\s*\\(member\\s+(.+)\\s+(.+)\\s*\\)\\s*.*", regex_constants::perl);
    regex re_member  = regex("\\s*\\(member\\s+(.+)\\s+(.+)\\s*\\).*", regex_constants::perl);
            
    //regex re_instanceref  = regex("\\s*([^\\(]+)\\s+\\(\\s*instanceRef\\s+([^\\s\\)]+)\\s*", regex_constants::perl);
    regex re_eof_obj  = regex("^\\s*\\)\\s*$", regex_constants::perl);
    
    Graph *graph = new Graph();
    
    //add XST default nodes for GND and VCC:
    Node *gnd = new Node_UNISIM_GND("XST_GND");
    graph->add_node(gnd);
    Node *vcc = new Node_UNISIM_VCC("XST_VCC");
    graph->add_node(vcc);
    
    int count = 0;
    
    //get filesize
    input_stream.seekg(0, ios_base::end);
    int maxlen = input_stream.tellg(); 
    input_stream.seekg(0, ios_base::beg);
    
    while( input_stream.good()){
        if (count++ == 200){
            printf("                                   \r> parsing edif %3d%% done : ",input_stream.tellg()*100/maxlen);
            cout.flush();
            count=0;
        }
        
        input_stream.getline(line, 2048);
        //printf("%d -%s-\n",parser_state,line); 
        
        //parse the edif
        switch(parser_state){
            ///initial state
            case(0):
                if (regex_match(line, re_result, re_main)){
                    parser_state = 1;
                }
                break;
                
            case(1):
                if (regex_match(line, re_result, re_port)){
                    //port definition, check next line if its input:
                    string port_name =  re_result[1].str();
              
                    input_stream.getline(line, 2048);
                    //input, create input node
                    //printf("'%s'\n\n",port_name.c_str());
                    Node *newnode;
                    
                    if (regex_match(port_name.c_str(), re_result, re_array)){
                        //multiple ios
                        int max =  atoi(re_result[3].str().c_str());
                        port_name = re_result[1].str();
                        for(int i=0; i<max; i++){
                            char buf[255];
                            sprintf(buf, "%s__%d", port_name.c_str(), i);
                            if (regex_match(line, re_result, re_is_input)){
                                newnode = new Node_INPUT(buf);
                            }else{
                                newnode = new Node_OUTPUT(buf);
                            }
                            graph->add_node(newnode); 
                            //printf("A '%s'\n",buf);
                        }
                    }else{
                        if (regex_match(line, re_result, re_is_input)){
                            newnode = new Node_INPUT(port_name.c_str());
                        }else{
                            newnode = new Node_OUTPUT(port_name.c_str());
                        }
                        graph->add_node(newnode); 
                        //printf("S '%s'\n",port_name.c_str());
                    }
                }else if(regex_match(line, re_result, re_instance)){
                    //this is an instance definition
                    instance = re_result[1].str();
                    if (regex_match(instance.c_str(), re_result, re_rename)){
                        //this is a rename, keep the new name
                        instance = re_result[1].str();
                    }
                    
                    //ok, we have an instance, change parser state
                    parser_state = 2;
                    ff_initvalue = 0;
                    
                    //printf("  instance [%s] ", instance.c_str());
                }else if(regex_match(line, re_result, re_net)){
                    //this is an net definition
                    net = re_result[1].str();
                    if (regex_match(net.c_str(), re_result, re_rename)){
                        //this is a rename, keep the new name
                        net = re_result[1].str();
                    }
                    
                    //ok we have a net, change parser state
                    parser_state = 3;
                    
                    //printf("NET %s\n",net.c_str());
                }else{
                    //TODO: add other info parser here
                    //printf("FIX PARSER [%s]\n",line);
                }
                break;
                
            ///parse instance details
            /** instance example: **    
                (instance (rename dout_renamed_0 "dout")
                (viewRef view_1 (cellRef FD (libraryRef UNISIMS)))
                (property XSTLIB (boolean (true)) (owner "Xilinx"))
                )
             */
            case(2):
                if (regex_match(line, re_result, re_viewref)){
                    //viewRef
                    celltype = re_result[1].str();
                    library  = re_result[2].str();
                    //printf(" celltype [%s] using lib <%s>\n", celltype.c_str(), library.c_str());
                }else if (regex_match(line, re_result, re_property)){
                    //property
                    string property    = re_result[1].str();
                    string value_type  = re_result[2].str();
                    string value_value = re_result[3].str();
                    
                    if (property == "INIT"){
                        //get type of init:
                        if (value_type == "boolean"){
                            sscanf(value_value.c_str(), "%d", &ff_initvalue);
                        }else if (value_type == "string"){
                            sscanf(value_value.c_str(), "%x", &ff_initvalue);
                        }else{
                            debug_printf("> dont know how to handle value type <%s>\n",value_type.c_str());
                        }
                    }else if (property == "XSTLIB"){
                        //no info for us...
                    }else if (property == "BUS_INFO"){
                        //no info for us...
                    }else{
                        debug_printf("> ignoring property <%s>\n",property.c_str());
                    }
                }else if(regex_match(line, re_result, re_eof_obj)){
                    //instance block finished -> create object
                    Node *newnode = graph->create_node(library.c_str(), instance.c_str(), celltype.c_str(), ff_initvalue);
                    graph->add_node(newnode);
                    
                    //go back to initial state
                    parser_state = 1;
                }else{
                    debug_printf("\n%d UKN -%s-\n",parser_state,line); 
                }
                break;
            
            ///parse net definition
            /** net example **
                (net (rename triplet_3_ok_ff_2__ "triplet_3_ok/ff<2>")
                (joined
                (portRef Q (instanceRef triplet_3_ok_ff_2))
                (portRef I1 (instanceRef triplet_3_ok_dout1))
                    )
                )
             */
            case(3):
                if (regex_match(line, re_result, re_portref)){
                    //printf("[%s]\n",line);
                    //prepare graph to connect
                    //string portref     = "Q";
                    //string instanceref = re_result[1].str();
                    wire wire;
                    wire.port = "Q";
                    wire.instance = re_result[1].str();
                    
                    if (regex_match(wire.instance.c_str(), re_result, re_member_instanceref)){
                        //if this is not an input we will get a correct instancename now:
                        //(member DOUT 0) instancebla
                        //         $1  $2    $3
                        wire.instance =  re_result[3].str() + "__" + re_result[1].str() + "__" +  re_result[2].str();
                        
                        wire.port = get_port_by_node_name(graph, wire.instance);
                    }else if (regex_match(wire.instance.c_str(), re_result, re_instanceref)){
                        //if this is not an input we will get a correct instancename now:
                        wire.port = re_result[1].str();
                        wire.instance = re_result[2].str();
                    }else if (regex_match(wire.instance.c_str(), re_result, re_member_io)){
                        wire.instance = re_result[1].str() + "__" + re_result[2].str();
                        wire.port = get_port_by_node_name(graph, wire.instance);
                    }else{
                        wire.port = get_port_by_node_name(graph, wire.instance);
                    }
                    /* no, need to check if this is in or output in order to set Q/D
                    }else if (regex_match(wire.instance.c_str(), re_result, re_member)){
                        //if this is not an input we will get a correct instancename now:
                        //(member aaaa 0)
                        //         $1  $2
                        wire.port = "Q";
                        wire.instance = re_result[1].str() + "__" + re_result[2].str();
                    }*/
                    
                    graph->prepare_connection(wire);
                }else if(regex_match(line, re_result, re_eof_obj)){
                    //eof this net, do all the connections
                    graph->execute_connections();
                    parser_state =1;
                }else if(regex_match(line, re_result, re_joined)){
                    //ignore this line
                    
                }else{
                    printf("invalid net info: %s\n",line);
                    exit(-1);
                }
                break;
                
                
            default:
                parser_state = 1;
        }
    }
    
    printf("      \r> parsing edif %3d%% done : ",input_stream.tellg()*100/maxlen);
    printf("\n> parsing done.\n");
    
    input_stream.close();
    return graph;
}

